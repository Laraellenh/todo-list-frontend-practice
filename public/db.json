
{ 
    "tasks" : [ 
    {
        "task": "DSA",
        "id": 1
    },
    {
        "task": "repeat Flatiron phase 2 coding challenge",
        "id": 2
    },
    {
        "task": "graph traversal",
        "id": 3
    },
    {
        "task": "review testing unit, integration, e2e using Jest",
        "id": 4
    },
    {
        "task": "repeat Flatiron phase 1 vanilla JS coding challenge",
        "id": 5
    },
    {
        "task": "review data modeling (this time from front end or back end for front end rather than ruby",
        "id": 6
    },
    {
        "task": " string manipulation including reversal, palindrome, capital/lowercase, integer to string and back",
        "id": 7
    },
    {
        "task": "review Magento",
        "id": 8
    },
    {
        "task": "review GraphQL and learn basics commands and installation",
        "id": 9
    },
    {
        "task": "review Docker including how to install and how it differs from Kubernetes",
        "id": 10
    },
    {
        "task": "frontend Podcast with expert",
        "id": 11
    },
    {
        "task": "review react hooks",
        "id": 12
    },
    {
        "task": "research react lifecycle methods and practice",
        "id": 13
    },
    {
        "task": "React practice assessment",
        "id": 14
    },
    {
        "task": "review interview best practices",
        "id": 15
    },
    {
        "task": "testing, edge cases",
        "id": 16
    },
    {
        "task": "how to approach Greefield Solution because React is so open ended - libraries, architecture, ect",
        "id": 17
    },
    {
        "task": "concurrency",
        "id": 18
    },
    {
        "task": "graph traversal",
        "id": 19
    },
    {
        "task": "leetcode 1 hour DSA",
        "id": 20
    },
    {
        "task": "leetcode 1 graph traversal",
        "id": 21
    },
    {
        "task": "Big O overview",
        "id": 22
    },
    {
        "task": "Big O practice",
        "id": 23
    }

    ],

"hooks": [
    {
    "hook": "useState",
    "function": "const [variable, setVariable = useState()",
    "uses": "keep track of value of variables between function calls (same as using this.state.) React preserves the variables. Can keep track of objects, strings, numbers, any data type"
    },
    {"hook": "useEffect",
    "function": "useEffect(()=> {function}, []) also common, useEffect(()=> {fetch(url).then(response=>response.json().then(setterFunction(variable) ",
    "uses": "fetch data, allows us to access count state variable inside the component or any props from the effect, its in the function of the scopt. It runs after first render and every update, so you may need to customize "
    },
    {"hook": "useContext",
    "function": "Const value = useContext(MyContext);",
    "uses": "Accepts a context object -the value returned from React.createContext - and returns the current context value. determined by the value of prop of the nearest <MyContext.Provider> above the calling component in the tree. Dont forget that the argument to useContext must be the context object itself. useContext(MyContext)" 
    },
    {"hook": "useReducer",
    "function": "Const [state, dispatch] = useReducer(reducer, initialArg, init);",
    "uses": "alternative to useState, accepts a reducer of type (state, action)=>newState, returns current state paired with dispatch method, similar to reduc. Good to optimize performance, share data widely, logic involves multiple subvalues (to avoid passing props over and over. "
    }
]


}